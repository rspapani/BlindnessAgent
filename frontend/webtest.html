<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Webcam Capture</title>
</head>
<body>
<video id="videoElement" width="640" height="480" autoplay></video>
<button id="captureButton">Capture</button>
<canvas id="canvas" style="display:none;"></canvas>
<button id="recordButton">Record</button>
<button id="playPauseButton">Pause</button>
<audio id="audioPlayer" controls></audio>
<div id="coloredSquare" style="width: 100px; height: 100px; background-color: blue;"></div>
<div id="downloadLinks"></div>

<script>


 let mediaRecorder;
 let chunks = [];

  // Check for media devices
  navigator.mediaDevices.getUserMedia({ audio: true })
    .then(function(stream) {
      // Assign the media stream to the media recorder
      mediaRecorder = new MediaRecorder(stream);

      // Event listener for when data is available
      mediaRecorder.ondataavailable = function(e) {
        chunks.push(e.data);
      };

      // Event listener for when recording stops
      mediaRecorder.onstop = function() {
        // Combine the recorded chunks into a single Blob
        let blob = new Blob(chunks, { type: 'audio/mpeg' });

        // Reset chunks
        chunks = [];

        // Create a URL for the Blob
        let audioURL = URL.createObjectURL(blob);
        console.log(audioURL)

        // Set the audio element's src to the recorded audio
        document.getElementById('audioPlayer').src = audioURL;
        const mp3Link = document.createElement('a');
        mp3Link.href = audioURL;
        mp3Link.download = 'recorded_audio.mp3';
        mp3Link.textContent = 'Download MP3';

      // Append the download link to the DOM
        const downloadLinks = document.getElementById('downloadLinks');
        downloadLinks.appendChild(mp3Link);
        fetch('http://localhost:5000/upload_audio', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ audio_url: audioURL }),
})
  .then(response => {
    if (response.ok) {
      console.log('Audio uploaded successfully');
    } else {
      console.error('Failed to upload image');
    }
  })
  .catch(error => {
    console.error('Error:', error);
  });
        
      };
    })
    .catch(function(err) {
      console.error('Error accessing media devices.', err);
    });

  // Event listener for record button click


  // Event listener for play/pause button click
  let audioPlayer = document.getElementById('audioPlayer');
  let playPauseButton = document.getElementById('playPauseButton');
  playPauseButton.addEventListener('click', function() {
    if (audioPlayer.paused) {
      audioPlayer.play();
    } else {
      audioPlayer.pause();
    }
  });

// Event listener for media session play event
navigator.mediaSession.setActionHandler('play', function() {
  if (audioPlayer.paused) {
    audioPlayer.play();
  }
});

// Event listener for media session pause event
navigator.mediaSession.setActionHandler('pause', function() {
  if (!audioPlayer.paused) {
    audioPlayer.pause();
  }
});

// Access the webcam
navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } }) // Try to use an external webcam if available
  .then(function(stream) {
    var video = document.getElementById('videoElement');
    video.srcObject = stream;
    video.onloadedmetadata = function(e) {
      video.play();
    };
  })
  .catch(function(err) {
    console.log("Failed to access external webcam, falling back to default webcam.");
    // Access the default webcam if the external one is not available
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(function(stream) {
        var video = document.getElementById('videoElement');
        video.srcObject = stream;
        video.onloadedmetadata = function(e) {
          video.play();
        };
      })
      .catch(function(err) {
        console.log("An error occurred: " + err);
      });
  });

// Capture button click event
document.getElementById('captureButton').addEventListener('click', function() {
  var video = document.getElementById('videoElement');
  var canvas = document.getElementById('canvas');
  var context = canvas.getContext('2d');

  // Set canvas dimensions to match video dimensions
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;

  // Draw the current frame from the video onto the canvas
  context.drawImage(video, 0, 0, canvas.width, canvas.height);

  // Convert the canvas content to a data URL representing a PNG image
  var dataURL = canvas.toDataURL('image/png');
  console.log(dataURL)

  // Create a link element to download the captured image
  var link = document.createElement('a');
  link.download = 'webcam_capture.png';
  link.href = dataURL;
  link.click();
  
  // Send POST request to image endpoint
  sendImage(dataURL);
});

let isRecording = false;
let square = document.getElementById('coloredSquare');
let recordingInterval; // Variable to store the recording interval

// Event listener to change square color on Enter key press
document.addEventListener('keydown', function(event) {
  if (event.key === 'Enter') {
    if (square.style.backgroundColor === 'blue') {
      square.style.backgroundColor = 'red';
    } else {
      square.style.backgroundColor = 'blue';
    }
  }
});

// Event listener to start recording interval when square becomes red
setInterval(function() {
  if (square.style.backgroundColor === 'red') {
    if (!recordingInterval) {
      startRecordingInterval();
    }
  } else {
    clearInterval(recordingInterval); // Stop recording interval if square becomes blue
    recordingInterval = null;
  }
}, 1000);

// Function to start the interval for recording every 30 seconds
function startRecordingInterval() {
  // Start recording immediately
  startRecording();

  // Set interval to record every 30 seconds
  recordingInterval = setInterval(function() {
    stopAndSendRecording();
    startRecording();
  }, 30000);
}

// Function to start recording
function startRecording() {
  isRecording = true;
  mediaRecorder.start();
  console.log('Recording started.');
}

// Function to stop recording and send the recorded media to the server
function stopAndSendRecording() {
  if (isRecording) {
    mediaRecorder.stop();
    console.log('Recording stopped.');
    isRecording = false;
    sendRecordingToServer();
  }
}

// Function to send the recorded media to the server
function sendRecordingToServer() {
  // Combine the recorded chunks into a single Blob
  let audioBlob = new Blob(chunks, { type: 'audio/mpeg' });

  // Reset chunks
  chunks = [];

  // Create a URL for the Blob
  let audioURL = URL.createObjectURL(audioBlob);
  console.log(audioURL);

  // Generate Unix timestamp
  let timestamp = Math.floor(Date.now() / 1000);

  // Send the recorded media and timestamp to the audio endpoint
  fetch('http://localhost:5000/upload_audio', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ audio_url: audioURL, timestamp: timestamp }),
  })
  .then(response => {
    if (response.ok) {
      console.log('Audio uploaded successfully');
    } else {
      console.error('Failed to upload audio');
    }
  })
  .catch(error => {
    console.error('Error:', error);
  });
}


function sendImage(dataURL) {
  // Generate Unix timestamp
  console.log("Called")
  var timestamp = Math.floor(Date.now() / 1000);

  // Send POST request to image endpoint with image data and timestamp
  fetch('http://localhost:5000/upload_image', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ image_base64: dataURL, timestamp: timestamp }),
  })
  .then(response => {
    if (response.ok) {
      console.log('Image uploaded successfully');
    } else {
      console.error('Failed to upload image');
    }
  })
  .catch(error => {
    console.error('Error:', error);
  });
}
setInterval(function() {
  var video = document.getElementById('videoElement');
  var canvas = document.getElementById('canvas');
  var context = canvas.getContext('2d');

  // Set canvas dimensions to match video dimensions
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;

  // Draw the current frame from the video onto the canvas
  context.drawImage(video, 0, 0, canvas.width, canvas.height);

  // Convert the canvas content to a data URL representing a PNG image
  var dataURL = canvas.toDataURL('image/png');
  console.log(dataURL)

  // Send POST request to image endpoint
  sendImage(dataURL);
}, 5000); // Repeat every 5 seconds


</script>

</body>
</html>

